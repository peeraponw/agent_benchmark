# Phase 1.2c: Common Infrastructure Templates

**Date Created**: 2024-12-19  
**Phase**: 1.2.3  
**Estimated Duration**: 3-4 hours  
**Dependencies**: Task 001 (Repository Structure)  

## Objective
Create reusable Docker infrastructure templates and configuration files that each framework will customize to ensure consistent deployment environments while maintaining framework isolation.

## Prerequisites
- Task 001 completed (repository structure exists)
- Docker and Docker Compose installed and configured
- Understanding of Docker networking and volume management

## Task Checklist

### Docker Compose Template Creation
- [x] Create `shared_infrastructure/docker-compose.template.yaml`
  - [x] Define Qdrant vector database service
    - [x] Use `qdrant/qdrant:latest` image
    - [x] Configure container name with `${FRAMEWORK_NAME}_qdrant` pattern
    - [x] Set port mapping using `${QDRANT_PORT}:6333`
    - [x] Create named volume for data persistence
    - [x] Configure framework-specific network
  - [x] Define Langfuse observability service
    - [x] Use `langfuse/langfuse:latest` image
    - [x] Configure container name with `${FRAMEWORK_NAME}_langfuse` pattern
    - [x] Set port mapping using `${LANGFUSE_PORT}:3000`
    - [x] Configure database connection environment variables
    - [x] Add dependency on PostgreSQL service
  - [x] Define PostgreSQL database service
    - [x] Use `postgres:15-alpine` image for stability
    - [x] Configure container name with `${FRAMEWORK_NAME}_postgres` pattern
    - [x] Set up database credentials using environment variables
    - [x] Create named volume for data persistence
    - [x] Configure proper database initialization

### Network and Volume Configuration
- [x] Define framework-specific Docker networks
  - [x] Create `${FRAMEWORK_NAME}_network` with bridge driver
  - [x] Ensure network isolation between frameworks
  - [x] Configure proper DNS resolution within networks

- [x] Define persistent volume configurations
  - [x] Create `${FRAMEWORK_NAME}_qdrant_data` volume for vector storage
  - [x] Create `${FRAMEWORK_NAME}_postgres_data` volume for database storage
  - [x] Ensure volume naming prevents conflicts between frameworks

### Environment Template Creation
- [x] Create framework-specific `.env.template` files (implemented in each framework directory)
  - [x] Define `FRAMEWORK_NAME` variable for customization
  - [x] Set `QDRANT_PORT` with framework-specific default
  - [x] Set `LANGFUSE_PORT` with framework-specific default
  - [x] Configure PostgreSQL credentials template
  - [x] Add placeholders for API keys (OpenRouter standardized)
  - [x] Include database connection string template
  - [x] Add observability configuration variables

### Port Allocation Strategy
- [x] Create `shared_infrastructure/PORT_ALLOCATION.md`
  - [x] Document port ranges for each framework
    - [x] CrewAI: 6333 (Qdrant), 3000 (Langfuse), 5432 (Postgres)
    - [x] DSPy: 6334 (Qdrant), 3001 (Langfuse), 5433 (Postgres)
    - [x] PocketFlow: 6335 (Qdrant), 3002 (Langfuse), 5434 (Postgres)
    - [x] Google ADK: 6336 (Qdrant), 3003 (Langfuse), 5435 (Postgres)
    - [x] Pydantic AI: 6337 (Qdrant), 3004 (Langfuse), 5436 (Postgres)
  - [x] Include conflict resolution guidelines
  - [x] Document how to check for port availability

### Health Check Configuration
- [x] Add health checks to all services in template
  - [x] Configure Qdrant health check endpoint
  - [x] Add PostgreSQL connection health check
  - [x] Configure Langfuse application health check
  - [x] Set appropriate timeout and retry parameters

### Resource Limits and Constraints
- [x] Define resource limits in Docker Compose template
  - [x] Set restart policies for service reliability (unless-stopped)
  - [ ] Set memory limits for each service (prevent resource hogging)
  - [ ] Configure CPU limits for fair resource sharing
  - [ ] Include logging configuration and rotation

### Template Customization Scripts
- [ ] Create `shared_infrastructure/customize_template.py`
  - [ ] Implement template variable substitution
  - [ ] Add validation for required environment variables
  - [ ] Include port conflict detection
  - [ ] Generate framework-specific configurations
  - [ ] Create backup of existing configurations

### Infrastructure Validation Tools
- [ ] Create `shared_infrastructure/validate_infrastructure.py`
  - [ ] Implement service connectivity tests
  - [ ] Add database connection validation
  - [ ] Check vector database functionality
  - [ ] Validate observability pipeline
  - [ ] Generate infrastructure health reports

### Monitoring and Logging Configuration
- [ ] Create `shared_infrastructure/logging.template.yaml`
  - [ ] Configure centralized logging for all services
  - [ ] Set up log rotation and retention policies
  - [ ] Define log format standards across frameworks
  - [ ] Include error alerting configuration templates

### Backup and Recovery Templates
- [ ] Create `shared_infrastructure/backup_scripts/`
  - [ ] Create database backup script template
  - [ ] Create vector database backup script template
  - [ ] Add automated backup scheduling configuration
  - [ ] Include disaster recovery procedures

### Security Configuration
- [ ] Add security best practices to templates
  - [ ] Configure non-root user execution where possible
  - [ ] Set up proper file permissions for volumes
  - [ ] Include network security configurations
  - [ ] Add secrets management guidelines

### Testing and Validation
- [ ] Create `shared_infrastructure/tests/`
  - [ ] Create template validation tests
  - [ ] Add infrastructure deployment tests
  - [ ] Include service connectivity tests
  - [ ] Create performance baseline tests

### Documentation
- [ ] Create `shared_infrastructure/README.md`
  - [ ] Document template usage and customization process
  - [ ] Provide step-by-step setup instructions
  - [ ] Include troubleshooting guide for common issues
  - [ ] Add best practices for infrastructure management
  - [ ] Document security considerations and recommendations

## Success Criteria
- [x] Docker Compose template supports all required services
- [x] Template variables allow proper framework customization
- [x] Port allocation prevents conflicts between frameworks
- [x] Health checks ensure service reliability
- [ ] Resource limits prevent framework interference (partial - restart policies implemented)
- [ ] Customization scripts work correctly for all frameworks
- [ ] Infrastructure validation tools detect common issues
- [ ] Documentation provides clear setup guidance (partial - MCP and port allocation docs exist)

## Implementation Notes
- Use environment variable substitution for all framework-specific values
- Ensure all services can be started independently for debugging
- Include comprehensive error handling in customization scripts
- Make templates easily extensible for additional services
- Follow Docker best practices for security and performance
- Test template customization with multiple framework configurations

## Next Steps
After completion, proceed to Task 005 (Phase 1.3: Test Data Preparation)
