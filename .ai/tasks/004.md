# Phase 1.2c: Common Infrastructure Templates

**Date Created**: 2024-12-19  
**Phase**: 1.2.3  
**Estimated Duration**: 3-4 hours  
**Dependencies**: Task 001 (Repository Structure)  

## Objective
Create reusable Docker infrastructure templates and configuration files that each framework will customize to ensure consistent deployment environments while maintaining framework isolation.

## Prerequisites
- Task 001 completed (repository structure exists)
- Docker and Docker Compose installed and configured
- Understanding of Docker networking and volume management

## Task Checklist

### Docker Compose Template Creation
- [ ] Create `shared_infrastructure/docker-compose.template.yaml`
  - [ ] Define Qdrant vector database service
    - [ ] Use `qdrant/qdrant:latest` image
    - [ ] Configure container name with `${FRAMEWORK_NAME}_qdrant` pattern
    - [ ] Set port mapping using `${QDRANT_PORT}:6333`
    - [ ] Create named volume for data persistence
    - [ ] Configure framework-specific network
  - [ ] Define Langfuse observability service
    - [ ] Use `langfuse/langfuse:latest` image
    - [ ] Configure container name with `${FRAMEWORK_NAME}_langfuse` pattern
    - [ ] Set port mapping using `${LANGFUSE_PORT}:3000`
    - [ ] Configure database connection environment variables
    - [ ] Add dependency on PostgreSQL service
  - [ ] Define PostgreSQL database service
    - [ ] Use `postgres:15` image for stability
    - [ ] Configure container name with `${FRAMEWORK_NAME}_postgres` pattern
    - [ ] Set up database credentials using environment variables
    - [ ] Create named volume for data persistence
    - [ ] Configure proper database initialization

### Network and Volume Configuration
- [ ] Define framework-specific Docker networks
  - [ ] Create `${FRAMEWORK_NAME}_network` with bridge driver
  - [ ] Ensure network isolation between frameworks
  - [ ] Configure proper DNS resolution within networks

- [ ] Define persistent volume configurations
  - [ ] Create `${FRAMEWORK_NAME}_qdrant_data` volume for vector storage
  - [ ] Create `${FRAMEWORK_NAME}_postgres_data` volume for database storage
  - [ ] Ensure volume naming prevents conflicts between frameworks

### Environment Template Creation
- [ ] Create `shared_infrastructure/.env.template`
  - [ ] Define `FRAMEWORK_NAME` variable for customization
  - [ ] Set `QDRANT_PORT` with framework-specific default
  - [ ] Set `LANGFUSE_PORT` with framework-specific default
  - [ ] Configure PostgreSQL credentials template
  - [ ] Add placeholders for API keys (OpenAI, Anthropic, Google)
  - [ ] Include database connection string template
  - [ ] Add observability configuration variables

### Port Allocation Strategy
- [ ] Create `shared_infrastructure/port_allocation.md`
  - [ ] Document port ranges for each framework
    - [ ] CrewAI: 6333 (Qdrant), 3000 (Langfuse), 5432 (Postgres)
    - [ ] DSPy: 6334 (Qdrant), 3001 (Langfuse), 5433 (Postgres)
    - [ ] PocketFlow: 6335 (Qdrant), 3002 (Langfuse), 5434 (Postgres)
    - [ ] Google ADK: 6336 (Qdrant), 3003 (Langfuse), 5435 (Postgres)
    - [ ] Pydantic AI: 6337 (Qdrant), 3004 (Langfuse), 5436 (Postgres)
  - [ ] Include conflict resolution guidelines
  - [ ] Document how to check for port availability

### Health Check Configuration
- [ ] Add health checks to all services in template
  - [ ] Configure Qdrant health check endpoint
  - [ ] Add PostgreSQL connection health check
  - [ ] Configure Langfuse application health check
  - [ ] Set appropriate timeout and retry parameters

### Resource Limits and Constraints
- [ ] Define resource limits in Docker Compose template
  - [ ] Set memory limits for each service (prevent resource hogging)
  - [ ] Configure CPU limits for fair resource sharing
  - [ ] Add restart policies for service reliability
  - [ ] Include logging configuration and rotation

### Template Customization Scripts
- [ ] Create `shared_infrastructure/customize_template.py`
  - [ ] Implement template variable substitution
  - [ ] Add validation for required environment variables
  - [ ] Include port conflict detection
  - [ ] Generate framework-specific configurations
  - [ ] Create backup of existing configurations

### Infrastructure Validation Tools
- [ ] Create `shared_infrastructure/validate_infrastructure.py`
  - [ ] Implement service connectivity tests
  - [ ] Add database connection validation
  - [ ] Check vector database functionality
  - [ ] Validate observability pipeline
  - [ ] Generate infrastructure health reports

### Monitoring and Logging Configuration
- [ ] Create `shared_infrastructure/logging.template.yaml`
  - [ ] Configure centralized logging for all services
  - [ ] Set up log rotation and retention policies
  - [ ] Define log format standards across frameworks
  - [ ] Include error alerting configuration templates

### Backup and Recovery Templates
- [ ] Create `shared_infrastructure/backup_scripts/`
  - [ ] Create database backup script template
  - [ ] Create vector database backup script template
  - [ ] Add automated backup scheduling configuration
  - [ ] Include disaster recovery procedures

### Security Configuration
- [ ] Add security best practices to templates
  - [ ] Configure non-root user execution where possible
  - [ ] Set up proper file permissions for volumes
  - [ ] Include network security configurations
  - [ ] Add secrets management guidelines

### Testing and Validation
- [ ] Create `shared_infrastructure/tests/`
  - [ ] Create template validation tests
  - [ ] Add infrastructure deployment tests
  - [ ] Include service connectivity tests
  - [ ] Create performance baseline tests

### Documentation
- [ ] Create `shared_infrastructure/README.md`
  - [ ] Document template usage and customization process
  - [ ] Provide step-by-step setup instructions
  - [ ] Include troubleshooting guide for common issues
  - [ ] Add best practices for infrastructure management
  - [ ] Document security considerations and recommendations

## Success Criteria
- [ ] Docker Compose template supports all required services
- [ ] Template variables allow proper framework customization
- [ ] Port allocation prevents conflicts between frameworks
- [ ] Health checks ensure service reliability
- [ ] Resource limits prevent framework interference
- [ ] Customization scripts work correctly for all frameworks
- [ ] Infrastructure validation tools detect common issues
- [ ] Documentation provides clear setup guidance

## Implementation Notes
- Use environment variable substitution for all framework-specific values
- Ensure all services can be started independently for debugging
- Include comprehensive error handling in customization scripts
- Make templates easily extensible for additional services
- Follow Docker best practices for security and performance
- Test template customization with multiple framework configurations

## Next Steps
After completion, proceed to Task 005 (Phase 1.3: Test Data Preparation)
